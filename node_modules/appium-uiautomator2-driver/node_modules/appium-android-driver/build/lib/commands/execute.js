"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = execute;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const support_1 = require("@appium/support");
const EXECUTE_SCRIPT_PREFIX = 'mobile:';
/**
 * Executes a script on the device or in a web context.
 *
 * @param script The script to execute. If it starts with 'mobile:', it will be treated
 * as a mobile command. Otherwise, it will be executed in the web context (if available).
 * @param args Optional arguments to pass to the script.
 * @returns Promise that resolves to the script execution result.
 * @throws {errors.NotImplementedError} If not in a web context and script doesn't start with 'mobile:'.
 */
async function execute(script, args) {
    if (lodash_1.default.startsWith(script, EXECUTE_SCRIPT_PREFIX)) {
        const formattedScript = script.trim().replace(/^mobile:\s*/, `${EXECUTE_SCRIPT_PREFIX} `);
        const executeMethodArgs = preprocessExecuteMethodArgs(args);
        return await this.executeMethod(formattedScript, [executeMethodArgs]);
    }
    if (!this.isWebContext()) {
        throw new driver_1.errors.NotImplementedError();
    }
    const endpoint = this.chromedriver.jwproxy
        .downstreamProtocol === driver_1.PROTOCOLS.MJSONWP
        ? '/execute'
        : '/execute/sync';
    return await this.chromedriver.jwproxy.command(endpoint, 'POST', {
        script,
        args,
    });
}
// #region Internal Helpers
/**
 * Massages the arguments going into an execute method.
 *
 * @param args Optional arguments to preprocess.
 * @returns Preprocessed arguments as a StringRecord.
 */
function preprocessExecuteMethodArgs(args) {
    const executeMethodArgs = (lodash_1.default.isArray(args) ? lodash_1.default.first(args) : args) ?? {};
    /**
     * Renames the deprecated `element` key to `elementId`.  Historically,
     * all of the pre-Execute-Method-Map execute methods accepted an `element` _or_ and `elementId` param.
     * This assigns the `element` value to `elementId` if `elementId` is not already present.
     */
    if (!('elementId' in executeMethodArgs) && 'element' in executeMethodArgs) {
        executeMethodArgs.elementId = executeMethodArgs.element;
    }
    /**
     * Automatically unwraps the `elementId` prop _if and only if_ the execute method expects it.
     */
    if ('elementId' in executeMethodArgs) {
        executeMethodArgs.elementId = support_1.util.unwrapElement(executeMethodArgs.elementId);
    }
    return executeMethodArgs;
}
//# sourceMappingURL=execute.js.map