"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lock = lock;
exports.isLocked = isLocked;
exports.unlock = unlock;
exports.mobileUnlock = mobileUnlock;
exports.unlockWithOptions = unlockWithOptions;
const bluebird_1 = __importDefault(require("bluebird"));
const helpers_1 = require("./helpers");
const lodash_1 = __importDefault(require("lodash"));
/**
 * Locks the device and optionally unlocks it after a specified number of seconds.
 *
 * @param seconds - Optional number of seconds to wait before unlocking. If not provided or invalid, the device remains locked.
 */
async function lock(seconds) {
    await this.adb.lock();
    if (Number.isNaN(seconds ?? NaN)) {
        return;
    }
    const floatSeconds = parseFloat(String(seconds));
    if (floatSeconds <= 0) {
        return;
    }
    await bluebird_1.default.delay(1000 * floatSeconds);
    await this.unlock();
}
/**
 * Checks if the device screen is currently locked.
 *
 * @returns True if the screen is locked, false otherwise
 */
async function isLocked() {
    return await this.adb.isScreenLocked();
}
/**
 * Unlocks the device using the unlock options from session capabilities.
 */
async function unlock() {
    await unlockWithOptions.bind(this)();
}
/**
 * Unlocks the device with the specified options.
 *
 * @param key - The unlock key. The value of this key depends on the actual unlock type and
 *              could be a pin/password/pattern value or a biometric finger id.
 *              If not provided then the corresponding value from session capabilities is used.
 * @param type - The unlock type. If not provided then the corresponding value from session capabilities is used.
 * @param strategy - Setting it to 'uiautomator' will enforce the driver to avoid using special
 *                  ADB shortcuts in order to speed up the unlock procedure. 'uiautomator' by default.
 * @param timeoutMs - The maximum time in milliseconds to wait until the screen gets unlocked. 2000ms by default.
 */
async function mobileUnlock(key, type, strategy, timeoutMs) {
    if (!key && !type) {
        await this.unlock();
    }
    else {
        await unlockWithOptions.bind(this)({
            unlockKey: key,
            unlockType: type,
            unlockStrategy: strategy,
            unlockSuccessTimeout: timeoutMs,
        });
    }
}
// #region Internal Helpers
/**
 * Unlocks the device with the specified capabilities.
 *
 * @param caps - Optional capabilities to use for unlocking. If not provided, uses session capabilities.
 */
async function unlockWithOptions(caps = null) {
    if (!(await this.adb.isScreenLocked())) {
        this.log.info('Screen already unlocked, doing nothing');
        return;
    }
    const capabilities = caps ?? this.opts;
    this.log.debug('Screen is locked, trying to unlock');
    if (!capabilities.unlockType && !capabilities.unlockKey) {
        this.log.info(`Neither 'unlockType' nor 'unlockKey' capability is provided. ` +
            `Assuming the device is locked with a simple lock screen.`);
        await this.adb.dismissKeyguard();
        return;
    }
    const validated = (0, helpers_1.validateUnlockCapabilities)(capabilities);
    const { unlockType, unlockKey, unlockStrategy, unlockSuccessTimeout } = validated;
    if (!unlockType) {
        throw new Error('unlockType is required after validation');
    }
    if (unlockKey &&
        unlockType !== helpers_1.FINGERPRINT_UNLOCK &&
        (lodash_1.default.isNil(unlockStrategy) || lodash_1.default.toLower(unlockStrategy) === 'locksettings') &&
        (await this.adb.isLockManagementSupported())) {
        await helpers_1.fastUnlock.bind(this)({
            credential: unlockKey,
            credentialType: (0, helpers_1.toCredentialType)(unlockType),
        });
    }
    else {
        const unlockMethodMap = {
            [helpers_1.PIN_UNLOCK]: helpers_1.pinUnlock,
            [helpers_1.PIN_UNLOCK_KEY_EVENT]: helpers_1.pinUnlockWithKeyEvent,
            [helpers_1.PASSWORD_UNLOCK]: helpers_1.passwordUnlock,
            [helpers_1.PATTERN_UNLOCK]: helpers_1.patternUnlock,
            [helpers_1.FINGERPRINT_UNLOCK]: helpers_1.fingerprintUnlock,
        };
        const unlockMethod = unlockMethodMap[unlockType];
        if (!unlockMethod) {
            throw new Error(`Unknown unlock type: ${unlockType}`);
        }
        await unlockMethod.bind(this)(capabilities);
    }
    await helpers_1.verifyUnlock.bind(this)(unlockSuccessTimeout);
}
// #endregion
//# sourceMappingURL=exports.js.map