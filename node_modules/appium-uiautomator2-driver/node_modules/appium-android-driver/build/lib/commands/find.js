"use strict";
/* eslint-disable @typescript-eslint/no-unused-vars */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findElOrEls = findElOrEls;
exports.doFindElementOrEls = doFindElementOrEls;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
async function findElOrEls(strategy, selector, mult, context = '') {
    if (!selector) {
        throw new Error('Must provide a selector when finding elements');
    }
    const params = {
        strategy,
        selector,
        context,
        multiple: mult,
    };
    let element;
    const doFind = async () => {
        try {
            element = await this.doFindElementOrEls(params);
        }
        catch (err) {
            // if the error that comes back is from a proxied request, we need to
            // unwrap it to its actual protocol error first
            if ((0, driver_1.isErrorType)(err, driver_1.errors.ProxyRequestError)) {
                err = err.getActualError(); // eslint-disable-line no-ex-assign
            }
            // now we have to inspect the error to determine if it is a no such
            // element error, based on the shape of the error object from
            // appium/driver
            if ((0, driver_1.isErrorType)(err, driver_1.errors.NoSuchElementError)) {
                // we are fine with this, just indicate a retry
                return false;
            }
            throw err;
        }
        // we want to return false if we want to potentially try again
        return !lodash_1.default.isEmpty(element);
    };
    try {
        await this.implicitWaitForCondition(doFind);
    }
    catch (e) {
        const err = e;
        if (err.message?.match(/Condition unmet/)) {
            // only get here if we are looking for multiple elements
            // condition was not met setting res to empty array
            element = [];
        }
        else {
            throw err;
        }
    }
    if (mult) {
        return element;
    }
    if (lodash_1.default.isEmpty(element)) {
        throw new driver_1.errors.NoSuchElementError();
    }
    return element;
}
/**
 * Performs the actual element search operation.
 *
 * This is an abstract method that must be implemented by subclasses or specific
 * context handlers (e.g., native context, webview context).
 *
 * @param params The search parameters containing strategy, selector, context, and multiple flag.
 * @returns A single `Element` if `params.multiple` is `false`, or an array of `Element` objects if `true`.
 * @throws {errors.NotImplementedError} This method must be implemented by the specific context handler.
 */
async function doFindElementOrEls(params) {
    throw new driver_1.errors.NotImplementedError('Not implemented');
}
//# sourceMappingURL=find.js.map