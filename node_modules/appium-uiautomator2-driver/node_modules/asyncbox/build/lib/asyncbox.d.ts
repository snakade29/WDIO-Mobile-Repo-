import B from 'bluebird';
import type { LongSleepOptions, WaitForConditionOptions } from './types.js';
/**
 * An async/await version of setTimeout
 */
export declare function sleep(ms: number): Promise<void>;
/**
 * Sometimes `Promise.delay` or `setTimeout` are inaccurate for large wait
 * times. To safely wait for these long times (e.g. in the 5+ minute range), you
 * can use `longSleep`.
 *
 * You can also pass a `progressCb` option which is a callback function that
 * receives an object with the properties `elapsedMs`, `timeLeft`, and
 * `progress`. This will be called on every wait interval so you can do your
 * wait logging or whatever.
 */
export declare function longSleep(ms: number, { thresholdMs, intervalMs, progressCb }?: LongSleepOptions): Promise<void>;
/**
 * An async/await way of running a method until it doesn't throw an error
 */
export declare function retry<T = any>(times: number, fn: (...args: any[]) => Promise<T>, ...args: any[]): Promise<T | null>;
/**
 * You can also use `retryInterval` to add a sleep in between retries. This can
 * be useful if you want to throttle how fast we retry.
 */
export declare function retryInterval<T = any>(times: number, sleepMs: number, fn: (...args: any[]) => Promise<T>, ...args: any[]): Promise<T | null>;
export declare const parallel: typeof B.all;
/**
 * Export async functions (Promises) and import this with your ES5 code to use
 * it with Node.
 */
export declare function nodeify<R = any>(promisey: any, cb: (err: any, value?: R) => void): Promise<R>;
/**
 * Node-ify an entire object of `Promise`-returning functions
 */
export declare function nodeifyAll<T extends Record<string, (...args: any[]) => any>>(promiseyMap: T): Record<string, (...args: any[]) => void>;
/**
 * Fire and forget async function execution
 */
export declare function asyncify(fn: (...args: any[]) => any | Promise<any>, ...args: any[]): void;
/**
 * Similar to `Array.prototype.map`; runs in serial or parallel
 */
export declare function asyncmap<T, R>(coll: T[], mapper: (value: T) => R | Promise<R>, runInParallel?: boolean): Promise<R[]>;
/**
 * Similar to `Array.prototype.filter`
 */
export declare function asyncfilter<T>(coll: T[], filter: (value: T) => boolean | Promise<boolean>, runInParallel?: boolean): Promise<T[]>;
/**
 * Takes a condition (a function returning a boolean or boolean promise), and
 * waits until the condition is true.
 *
 * Throws a `/Condition unmet/` error if the condition has not been satisfied
 * within the allocated time, unless an error is provided in the options, as the
 * `error` property, which is either thrown itself, or used as the message.
 *
 * The condition result is returned if it is not falsy. If the condition throws an
 * error then this exception will be immediately passed through.
 *
 * The default options are: `{ waitMs: 5000, intervalMs: 500 }`
 */
export declare function waitForCondition<T>(condFn: () => Promise<T> | T, options?: WaitForConditionOptions): Promise<T>;
//# sourceMappingURL=asyncbox.d.ts.map