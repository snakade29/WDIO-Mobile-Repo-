"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CssConverter = void 0;
const css_selector_parser_1 = require("css-selector-parser");
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const logger_1 = require("./logger");
const parseCssSelector = (0, css_selector_parser_1.createParser)({
    syntax: {
        pseudoClasses: {
            unknown: 'accept',
            definitions: {
                Selector: ['has'],
            },
        },
        combinators: ['>', '+', '~'],
        attributes: {
            operators: ['^=', '$=', '*=', '~=', '='],
        },
        ids: true,
        classNames: true,
        tag: {
            wildcard: true,
        },
    },
    substitutes: true,
});
const RESOURCE_ID = 'resource-id';
const ID_LOCATOR_PATTERN = /^[a-zA-Z_][a-zA-Z0-9._]*:id\/[\S]+$/;
const BOOLEAN_ATTRS = [
    'checkable',
    'checked',
    'clickable',
    'enabled',
    'focusable',
    'focused',
    'long-clickable',
    'scrollable',
    'selected',
];
const NUMERIC_ATTRS = ['index', 'instance'];
const STR_ATTRS = ['description', RESOURCE_ID, 'text', 'class-name', 'package-name'];
const ALL_ATTRS = [...BOOLEAN_ATTRS, ...NUMERIC_ATTRS, ...STR_ATTRS];
const ATTRIBUTE_ALIASES = [
    [RESOURCE_ID, ['id']],
    [
        'description',
        ['content-description', 'content-desc', 'desc', 'accessibility-id'],
    ],
    ['index', ['nth-child']],
];
const isAstAttribute = (item) => item.type === 'Attribute';
const isAstPseudoClass = (item) => item.type === 'PseudoClass';
const isAstClassName = (item) => item.type === 'ClassName';
const isAstTagName = (item) => item.type === 'TagName';
const isAstId = (item) => item.type === 'Id';
function toSnakeCase(str) {
    if (!str) {
        return '';
    }
    const tokens = str
        .split('-')
        .map((token) => token.charAt(0).toUpperCase() + token.slice(1).toLowerCase());
    const out = tokens.join('');
    return out.charAt(0).toLowerCase() + out.slice(1);
}
function requireBoolean(css) {
    const rawValue = css.value?.value ?? css.argument?.value;
    const value = lodash_1.default.toLower(rawValue ?? 'true');
    if (value === 'true') {
        return 'true';
    }
    if (value === 'false') {
        return 'false';
    }
    throw new Error(`'${css.name}' must be true, false or empty. Found '${css.value}'`);
}
function requireEntityName(cssEntity) {
    const attrName = cssEntity.name.toLowerCase();
    if (ALL_ATTRS.includes(attrName)) {
        return attrName;
    }
    for (const [officialAttr, aliasAttrs] of ATTRIBUTE_ALIASES) {
        if (aliasAttrs.includes(attrName)) {
            return officialAttr;
        }
    }
    throw new Error(`'${attrName}' is not a valid attribute. Supported attributes are '${ALL_ATTRS.join(', ')}'`);
}
function getWordMatcherRegex(word) {
    return `\\b(\\w*${lodash_1.default.escapeRegExp(word)}\\w*)\\b`;
}
class CssConverter {
    selector;
    pkg;
    constructor(selector, pkg) {
        this.selector = selector;
        this.pkg = pkg;
    }
    toUiAutomatorSelector() {
        let cssObj;
        try {
            cssObj = parseCssSelector(this.selector);
        }
        catch (e) {
            logger_1.log.debug(e.stack);
            throw new driver_1.errors.InvalidSelectorError(`Invalid CSS selector '${this.selector}'. Reason: '${e.message}'`);
        }
        try {
            return this.parseCssObject(cssObj);
        }
        catch (e) {
            logger_1.log.debug(e.stack);
            throw new driver_1.errors.InvalidSelectorError(`Unsupported CSS selector '${this.selector}'. Reason: '${e.message}'`);
        }
    }
    formatIdLocator(locator) {
        return ID_LOCATOR_PATTERN.test(locator) ? locator : `${this.pkg || 'android'}:id/${locator}`;
    }
    parseAttr(cssAttr) {
        const attrValueNode = cssAttr.value;
        const attrValue = attrValueNode?.value;
        if (!lodash_1.default.isString(attrValue) && !lodash_1.default.isEmpty(attrValue)) {
            throw new Error(`'${cssAttr.name}=${attrValue}' is an invalid attribute. Only 'string' and empty attribute types are supported. Found '${attrValue}'`);
        }
        const attrName = requireEntityName(cssAttr);
        const methodName = toSnakeCase(attrName);
        if (!STR_ATTRS.includes(attrName) && !BOOLEAN_ATTRS.includes(attrName)) {
            throw new Error(`'${attrName}' is not supported. Supported attributes are '${[...STR_ATTRS, ...BOOLEAN_ATTRS].join(', ')}'`);
        }
        if (BOOLEAN_ATTRS.includes(attrName)) {
            return `.${methodName}(${requireBoolean(cssAttr)})`;
        }
        let value = attrValue || '';
        if (attrName === RESOURCE_ID) {
            value = this.formatIdLocator(value);
        }
        if (value === '') {
            return `.${methodName}Matches("")`;
        }
        switch (cssAttr.operator) {
            case '=':
                return `.${methodName}("${value}")`;
            case '*=':
                if (['description', 'text'].includes(attrName)) {
                    return `.${methodName}Contains("${value}")`;
                }
                return `.${methodName}Matches("${lodash_1.default.escapeRegExp(value)}")`;
            case '^=':
                if (['description', 'text'].includes(attrName)) {
                    return `.${methodName}StartsWith("${value}")`;
                }
                return `.${methodName}Matches("^${lodash_1.default.escapeRegExp(value)}")`;
            case '$=':
                return `.${methodName}Matches("${lodash_1.default.escapeRegExp(value)}$")`;
            case '~=':
                return `.${methodName}Matches("${getWordMatcherRegex(value)}")`;
            default:
                throw new Error(`Unsupported CSS attribute operator '${cssAttr.operator}'.  '=', '*=', '^=', '$=' and '~=' are supported.`);
        }
    }
    parsePseudo(cssPseudo) {
        const argValue = cssPseudo.argument?.value;
        if (!lodash_1.default.isString(argValue) && !lodash_1.default.isEmpty(argValue)) {
            throw new Error(`'${cssPseudo.name}=${argValue}'. Unsupported css pseudo class value: '${argValue}'. Only 'string' type or empty is supported.`);
        }
        const pseudoName = requireEntityName(cssPseudo);
        if (BOOLEAN_ATTRS.includes(pseudoName)) {
            return `.${toSnakeCase(pseudoName)}(${requireBoolean(cssPseudo)})`;
        }
        if (NUMERIC_ATTRS.includes(pseudoName)) {
            return `.${pseudoName}(${argValue})`;
        }
    }
    parseCssRule(cssRule) {
        if (cssRule.combinator && ![' ', '>'].includes(cssRule.combinator)) {
            throw new Error(`'${cssRule.combinator}' is not a supported combinator. Only child combinator (>) and descendant combinator are supported.`);
        }
        const uiAutomatorSelector = ['new UiSelector()'];
        const items = cssRule.items ?? [];
        const astClassNames = items.filter(isAstClassName);
        const classNames = astClassNames.map(({ name }) => name);
        const astTag = items.find(isAstTagName);
        const tagName = astTag?.name;
        if (tagName && tagName !== '*') {
            const androidClass = [tagName];
            if (classNames.length) {
                for (const cssClassNames of classNames) {
                    androidClass.push(cssClassNames);
                }
                uiAutomatorSelector.push(`.className("${androidClass.join('.')}")`);
            }
            else {
                uiAutomatorSelector.push(`.classNameMatches("${tagName}")`);
            }
        }
        else if (classNames.length) {
            uiAutomatorSelector.push(`.classNameMatches("${classNames.join('\\.')}")`);
        }
        const astIds = items.filter(isAstId);
        const ids = astIds.map(({ name }) => name);
        if (ids.length) {
            uiAutomatorSelector.push(`.resourceId("${this.formatIdLocator(ids[0])}")`);
        }
        const attributes = items.filter(isAstAttribute);
        for (const attr of attributes) {
            uiAutomatorSelector.push(this.parseAttr(attr));
        }
        const pseudoClasses = items.filter(isAstPseudoClass);
        for (const pseudo of pseudoClasses) {
            const sel = this.parsePseudo(pseudo);
            if (sel) {
                uiAutomatorSelector.push(sel);
            }
        }
        if (cssRule.nestedRule) {
            uiAutomatorSelector.push(`.childSelector(${this.parseCssRule(cssRule.nestedRule)})`);
        }
        return uiAutomatorSelector.join('');
    }
    parseCssObject(css) {
        if (!lodash_1.default.isEmpty(css.rules)) {
            return this.parseCssRule(css.rules[0]);
        }
        throw new Error('No rules could be parsed out of the current selector');
    }
}
exports.CssConverter = CssConverter;
//# sourceMappingURL=css-converter.js.map